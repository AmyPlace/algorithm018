## 遞歸 Recursion 學習筆記

### 總結

- Step1 : 找重複性

- Step2 : 分解問題

- Step3 : 組合子問題的結果

### 特性

- 擁有重複性(自相似性)

- 遞歸通過函數體來進行的循環

- 函數呼叫具對稱性/參數傳遞

- 最近重複性

### 需要滿足的條件

- 1. 一個問題可以分解成幾個子運題

- 2. 這個問題與分解之後的子問題，除了數據規模不同，求解思路完全一樣

- 3. 存在遞歸終止條件

### 關鍵步驟

- 0. 編寫遞歸代碼的關鍵就是不要把自己繞進去

- 1. 找到把大問題分解成小問題的規律

- 2. 透過規律，先寫出遞推公式

- 3. 找到終止條件

- 4. 實現代碼

### 思考

- 如果一个问题 A 可以分解为若干子问题 B、C、D，你可以假设子问题 B、C、D 已经解决，在此基础上思考如何解决问题 A。而且，你只需要思考问题 A 与子问题 B、C、D 两层之间的关系即可，不需要一层一层往下思考子问题与子子问题，子子问题与子子子问题之间的关系。屏蔽掉递归细节，这样子理解起来就简单多了。因此，编写递归代码的关键是，只要遇到递归，我们就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤。

- 不要试图用人脑去分解递归的每个步骤。

### 思維要點

- 不要人肉遞歸

- 找到最近最簡子問題，將其拆解成可重複解決的問題

- 數學歸納法的思維

### 分治 Dicide & Conquer

- 就是一種遞歸

- 找重複性與分解問題

- 拆分子問題，組合多個子結果

- LeetCode

  - 50.Pow(x, n) 

  - 78.子集

### 回溯 Backtrace

- 特性

  - 就是一種遞歸

  - 在每一層去試錯的思想

  - 回溯算法稱為爆搜（暴力解法）  
    因此回溯算法常用於搜索一個問題的所有的解

- LeetCode

  - 169. 多数元素

  - 17. 电话号码的字母组合

  - 51. N 皇后

### 可能遇到的問題

- 遞歸代碼堆棧溢出

  - 解法

    - 透過在程式碼中限制遞歸調用的最大深度的方式，適用於深度較小的應用

- 重複計算

  - 解法

    - 用 HashMap 來保存已經求解過的結果

### LeetCode

- 70.爬楼梯
- 22.括号生成
- 226. 翻转二叉树
- 98. 验证二叉搜索树
- 104. 二叉树的最大深度
- 111. 二叉树的最小深度
- 297. 二叉树的序列化与反序列化
- 236. 二叉树的最近公共祖先
- 105. 从前序与中序遍历序列构造二叉树
- 77. 组合
- 46. 全排列
- 47. 全排列 II 



作業

| [二叉树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/) | 代補                         |
| ------------------------------------------------------------ | ---------------------------- |
| [从前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/) | 代補                         |
| [组合](https://leetcode-cn.com/problems/combinations/)       | [⭕](./HW/[77]组合.java)      |
| [全排列](https://leetcode-cn.com/problems/permutations/)     | [⭕](./HW/[46]全排列.java)    |
| [全排列 II ](https://leetcode-cn.com/problems/permutations-ii/) | [⭕](./HW/[47]全排列_II.java) |

